<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinese Chess (Xiangqi) Pro</title>
    <style>
        :root {
            --board-bg: #eecfa1;
            --line-color: #5d4037;
            --piece-size: 45px;
            --highlight-color: rgba(0, 255, 0, 0.5);
            --selected-color: rgba(0, 0, 255, 0.4);
            --last-move-color: rgba(255, 255, 0, 0.4);
            --shadow-color: rgba(0, 0, 0, 0.4);
        }

        body {
            font-family: 'Noto Serif SC', serif;
            background-color: #2c2c2c;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            position: relative;
            background-color: var(--board-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            user-select: none;
            -webkit-user-select: none;
        }

        #board-svg {
            position: absolute;
            top: 20px;
            left: 20px;
            width: calc(100% - 40px);
            height: calc(100% - 40px);
            pointer-events: none;
        }

        line, rect, path {
            stroke: var(--line-color);
            stroke-width: 2;
            fill: none;
        }
        
        .board-text {
            fill: var(--line-color);
            font-size: 24px;
            font-family: "KaiTi", "STKaiti", serif; 
            text-anchor: middle;
            dominant-baseline: middle;
            opacity: 0.6;
            writing-mode: vertical-rl;
            text-orientation: upright;
        }

        #board-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(10, 1fr);
            width: 400px;
            height: 450px;
            position: relative;
            z-index: 10;
        }

        .cell {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20%;
            height: 20%;
            background-color: var(--highlight-color);
            border-radius: 50%;
            pointer-events: none;
            display: none;
            z-index: 5;
        }

        .cell.valid-move .indicator { display: block; }
        .cell.selected-cell { background-color: var(--selected-color); }
        .cell.last-move { background-color: var(--last-move-color); }

        .piece {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            background: #fdf5e6;
            border: 4px solid #dcb35c;
            box-shadow: 2px 2px 5px var(--shadow-color), inset -2px -2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            position: absolute;
            top: 7.5%;
            left: 7.5%;
            z-index: 20;
            transition: transform 0.2s ease-out;
        }
        
        .piece::before {
            content: '';
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.1);
            pointer-events: none;
        }

        .piece.red { color: #c00; border-color: #e8b079; }
        .piece.black { color: #222; border-color: #e8b079; }

        #ui-panel {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            background: #444;
            padding: 10px 20px;
            border-radius: 50px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            flex-wrap: wrap;
            justify-content: center;
        }

        #status {
            font-size: 1.1em;
            font-weight: bold;
            min-width: 100px;
            text-align: center;
        }

        select {
            background: #5d4037;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            outline: none;
        }

        button {
            background: #5d4037;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        button:hover { background: #795548; }

        .turn-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            border: 2px solid #fff;
        }

        #modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #modal-content {
            background: #fff;
            color: #000;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            min-width: 200px;
        }
        #modal h2 { margin-top: 0; }

        @media (max-width: 600px) {
            #ui-panel { width: 90%; padding: 10px; }
            .piece { font-size: 18px; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <svg id="board-svg" viewBox="0 0 360 400" preserveAspectRatio="none">
            <rect x="0" y="0" width="360" height="400" fill="none" />
            <g id="grid-verticals">
                <line x1="20" y1="20" x2="20" y2="180" />
                <line x1="60" y1="20" x2="60" y2="180" />
                <line x1="100" y1="20" x2="100" y2="180" />
                <line x1="140" y1="20" x2="140" y2="180" />
                <line x1="180" y1="20" x2="180" y2="180" />
                <line x1="220" y1="20" x2="220" y2="180" />
                <line x1="260" y1="20" x2="260" y2="180" />
                <line x1="300" y1="20" x2="300" y2="180" />
                <line x1="340" y1="20" x2="340" y2="180" />
                <line x1="20" y1="220" x2="20" y2="380" />
                <line x1="60" y1="220" x2="60" y2="380" />
                <line x1="100" y1="220" x2="100" y2="380" />
                <line x1="140" y1="220" x2="140" y2="380" />
                <line x1="180" y1="220" x2="180" y2="380" />
                <line x1="220" y1="220" x2="220" y2="380" />
                <line x1="260" y1="220" x2="260" y2="380" />
                <line x1="300" y1="220" x2="300" y2="380" />
                <line x1="340" y1="220" x2="340" y2="380" />
                <line x1="20" y1="180" x2="20" y2="220" />
                <line x1="340" y1="180" x2="340" y2="220" />
            </g>
            <g id="grid-horizontals">
                <line x1="20" y1="20" x2="340" y2="20" />
                <line x1="20" y1="60" x2="340" y2="60" />
                <line x1="20" y1="100" x2="340" y2="100" />
                <line x1="20" y1="140" x2="340" y2="140" />
                <line x1="20" y1="180" x2="340" y2="180" />
                <line x1="20" y1="220" x2="340" y2="220" />
                <line x1="20" y1="260" x2="340" y2="260" />
                <line x1="20" y1="300" x2="340" y2="300" />
                <line x1="20" y1="340" x2="340" y2="340" />
                <line x1="20" y1="380" x2="340" y2="380" />
            </g>
            <line x1="140" y1="20" x2="220" y2="100" />
            <line x1="220" y1="20" x2="140" y2="100" />
            <line x1="140" y1="300" x2="220" y2="380" />
            <line x1="220" y1="300" x2="140" y2="380" />
            <text x="90" y="200" class="board-text">楚 河</text>
            <text x="270" y="200" class="board-text">漢 界</text>
            
            <defs>
                <g id="marker">
                    <path d="M -3 -10 L -3 -3 L -10 -3" /> <path d="M 3 -10 L 3 -3 L 10 -3" />
                    <path d="M -3 10 L -3 3 L -10 3" /> <path d="M 3 10 L 3 3 L 10 3" />
                </g>
                <g id="marker-right">
                    <path d="M -3 -10 L -3 -3 L -10 -3" /> <path d="M -3 10 L -3 3 L -10 3" />
                </g>
                <g id="marker-left">
                    <path d="M 3 -10 L 3 -3 L 10 -3" /> <path d="M 3 10 L 3 3 L 10 3" />
                </g>
            </defs>
            <use href="#marker" x="60" y="100" /> <use href="#marker" x="300" y="100" />
            <use href="#marker" x="60" y="300" /> <use href="#marker" x="300" y="300" />
            <use href="#marker-left" x="20" y="140" /> <use href="#marker" x="100" y="140" />
            <use href="#marker" x="180" y="140" /> <use href="#marker" x="260" y="140" /> <use href="#marker-right" x="340" y="140" />
            <use href="#marker-left" x="20" y="260" /> <use href="#marker" x="100" y="260" />
            <use href="#marker" x="180" y="260" /> <use href="#marker" x="260" y="260" /> <use href="#marker-right" x="340" y="260" />
        </svg>
        <div id="board-grid"></div>
    </div>

    <div id="ui-panel">
        <div style="display:flex; align-items:center;">
            <div id="turn-light" class="turn-indicator"></div>
            <span id="status">Red's Turn</span>
        </div>
        <select id="mode-select" onchange="changeMode(this.value)">
            <option value="PvP">Player vs Player</option>
            <option value="PvAI" selected>Player vs AI</option>
        </select>
        <select id="ai-level" onchange="changeDifficulty(this.value)">
            <option value="1">Easy (Depth 2)</option>
            <option value="2" selected>Normal (Depth 3+)</option>
        </select>
        <button onclick="resetGame()">New Game</button>
    </div>

    <div id="modal">
        <div id="modal-content">
            <h2 id="modal-msg">Game Over</h2>
            <button onclick="closeModal()">Play Again</button>
        </div>
    </div>

    <script>
        // --- Constants ---
        const ROWS = 10;
        const COLS = 9;
        const RED = 'red';
        const BLACK = 'black';

        // R=Red, r=Black (lowercase). 
        const INITIAL_BOARD = [
            ['r', 'n', 'b', 'a', 'k', 'a', 'b', 'n', 'r'],
            ['.', '.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', 'c', '.', '.', '.', '.', '.', 'c', '.'],
            ['p', '.', 'p', '.', 'p', '.', 'p', '.', 'p'],
            ['.', '.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.', '.'],
            ['P', '.', 'P', '.', 'P', '.', 'P', '.', 'P'],
            ['.', 'C', '.', '.', '.', '.', '.', 'C', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.', '.'],
            ['R', 'N', 'B', 'A', 'K', 'A', 'B', 'N', 'R']
        ];

        const PIECE_NAMES = {
            'k': '將', 'K': '帥', 'a': '士', 'A': '仕', 'b': '象', 'B': '相',
            'n': '馬', 'N': '傌', 'r': '車', 'R': '俥', 'c': '砲', 'C': '炮',
            'p': '卒', 'P': '兵'
        };

        // --- Game State ---
        let board = [];
        let turn = RED;
        let selectedPos = null;
        let validMoves = [];
        let gameOver = false;
        let gameMode = 'PvAI';
        let aiDepth = 3;
        const AI_COLOR = BLACK;
        const PLAYER_COLOR = RED;
        let isAiThinking = false;
        let lastMove = null; // {from: {r,c}, to: {r,c}}

        // --- Initialization ---
        function init() {
            const grid = document.getElementById('board-grid');
            grid.innerHTML = '';
            board = JSON.parse(JSON.stringify(INITIAL_BOARD));
            lastMove = null;
            
            resizeBoard();
            window.addEventListener('resize', resizeBoard);

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    const indicator = document.createElement('div');
                    indicator.className = 'indicator';
                    cell.appendChild(indicator);
                    
                    cell.addEventListener('click', () => handleCellClick(r, c));
                    grid.appendChild(cell);
                }
            }
            renderBoard();
            updateStatus();
        }

        function resizeBoard() {
            const grid = document.getElementById('board-grid');
            const maxW = window.innerWidth - 40;
            const maxH = window.innerHeight - 140;
            let size = Math.min(maxW / 9, maxH / 10);
            if (size > 60) size = 60;
            
            grid.style.width = `${size * 9}px`;
            grid.style.height = `${size * 10}px`;
            document.documentElement.style.setProperty('--piece-size', `${size}px`);
            
            const pieces = document.querySelectorAll('.piece');
            pieces.forEach(p => p.style.fontSize = `${size * 0.5}px`);
        }

        // --- Core Logic ---
        function getPiece(r, c) {
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return null;
            const char = board[r][c];
            if (char === '.') return null;
            return {
                type: char.toLowerCase(),
                color: (char === char.toUpperCase()) ? RED : BLACK,
                char: char
            };
        }

        function renderBoard() {
            const cells = document.querySelectorAll('.cell');
            const cellSize = document.getElementById('board-grid').offsetWidth / 9;

            cells.forEach(cell => {
                const r = parseInt(cell.dataset.r);
                const c = parseInt(cell.dataset.c);
                const piece = getPiece(r, c);
                
                // Cleanup
                const existingPiece = cell.querySelector('.piece');
                if (existingPiece) cell.removeChild(existingPiece);
                cell.classList.remove('selected-cell', 'valid-move', 'last-move');

                if (piece) {
                    const pDiv = document.createElement('div');
                    pDiv.className = `piece ${piece.color}`;
                    pDiv.innerText = PIECE_NAMES[piece.char];
                    pDiv.style.fontSize = `${cellSize * 0.5}px`;
                    cell.appendChild(pDiv);
                }

                if (selectedPos && selectedPos.r === r && selectedPos.c === c) cell.classList.add('selected-cell');
                if (validMoves.some(m => m.r === r && m.c === c)) cell.classList.add('valid-move');
                if (lastMove && ((lastMove.from.r===r && lastMove.from.c===c) || (lastMove.to.r===r && lastMove.to.c===c))) {
                    cell.classList.add('last-move');
                }
            });
        }

        function handleCellClick(r, c) {
            if (gameOver || isAiThinking) return;
            if (gameMode === 'PvAI' && turn === AI_COLOR) return;

            const clickedPiece = getPiece(r, c);
            const isOwnPiece = clickedPiece && clickedPiece.color === turn;

            if (isOwnPiece) {
                selectedPos = { r, c };
                validMoves = getValidMoves(r, c, clickedPiece.type, clickedPiece.color);
                renderBoard();
                return;
            }

            if (selectedPos) {
                const move = validMoves.find(m => m.r === r && m.c === c);
                if (move) {
                    executeMove(selectedPos, { r, c });
                } else {
                    selectedPos = null;
                    validMoves = [];
                    renderBoard();
                }
            }
        }

        function executeMove(from, to) {
            const targetPiece = getPiece(to.r, to.c);
            const movingPieceChar = board[from.r][from.c];
            
            if (targetPiece && targetPiece.type === 'k') {
                gameOver = true;
                renderBoard();
                showModal(`${turn === RED ? "Red" : "Black"} Wins!`);
                return;
            }

            board[to.r][to.c] = movingPieceChar;
            board[from.r][from.c] = '.';
            lastMove = {from, to};

            if (generalsFaceEachOther(board)) {
                // Revert
                board[from.r][from.c] = movingPieceChar;
                board[to.r][to.c] = targetPiece ? targetPiece.char : '.';
                lastMove = null;
                if (!isAiThinking) alert("Illegal Move: Generals cannot face each other!");
                return;
            }

            selectedPos = null;
            validMoves = [];
            turn = turn === RED ? BLACK : RED;
            updateStatus();
            renderBoard();

            if (!gameOver && gameMode === 'PvAI' && turn === AI_COLOR) {
                isAiThinking = true;
                // Allow UI update before AI freezes thread
                setTimeout(makeAiMove, 100);
            }
        }

        function generalsFaceEachOther(currentBoard) {
            let redK, blackK;
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    if (currentBoard[r][c] === 'K') redK = {r, c};
                    if (currentBoard[r][c] === 'k') blackK = {r, c};
                }
            }
            if (!redK || !blackK) return false;
            if (redK.c !== blackK.c) return false;
            const minR = Math.min(redK.r, blackK.r);
            const maxR = Math.max(redK.r, blackK.r);
            for (let r = minR + 1; r < maxR; r++) {
                if (currentBoard[r][redK.c] !== '.') return false;
            }
            return true;
        }

        function updateStatus() {
            const statusEl = document.getElementById('status');
            const light = document.getElementById('turn-light');
            
            if (isAiThinking) {
                statusEl.innerText = "Thinking...";
                statusEl.style.color = "#aaa";
                light.style.backgroundColor = "#555";
                return;
            }
            if (turn === RED) {
                statusEl.innerText = "Red Turn";
                statusEl.style.color = "#e57373";
                light.style.backgroundColor = "#c00";
            } else {
                statusEl.innerText = "Black Turn";
                statusEl.style.color = "#aaa";
                light.style.backgroundColor = "#000";
            }
        }

        function changeMode(val) {
            gameMode = val;
            resetGame();
        }
        function changeDifficulty(val) {
            aiDepth = parseInt(val) === 1 ? 2 : 3;
        }
        function resetGame() {
            gameOver = false;
            turn = RED;
            selectedPos = null;
            validMoves = [];
            isAiThinking = false;
            document.getElementById('modal').style.display = 'none';
            init();
        }
        function closeModal() { resetGame(); }
        function showModal(msg) {
            document.getElementById('modal-msg').innerText = msg;
            document.getElementById('modal').style.display = 'flex';
        }

        // --- Advanced AI Logic (PST + Quiescence) ---

        // Piece Square Tables (for BLACK pieces on Top, RED on Bottom)
        // AI is BLACK. We define tables from Black's perspective (row 0 is top).
        // For Red, we flip the row index.
        
        const PST = {
            // Pawn: Advances = good. Crossing river (row > 4 for black) = great.
            'p': [
                [0,  0,  0,  0,  0,  0,  0,  0,  0],
                [0,  0,  0,  0,  0,  0,  0,  0,  0],
                [0,  0,  0,  0,  0,  0,  0,  0,  0],
                [0,  0,  0,  0,  0,  0,  0,  0,  0], // River boundary
                [10, 0, 10,  0, 10,  0, 10,  0, 10], // River crossed
                [10, 10, 10, 10, 10, 10, 10, 10, 10],
                [20, 20, 20, 20, 20, 20, 20, 20, 20], // Deep in enemy territory
                [30, 30, 30, 30, 30, 30, 30, 30, 30],
                [40, 40, 40, 40, 40, 40, 40, 40, 40],
                [50, 50, 50, 50, 50, 50, 50, 50, 50]
            ],
            // Horse: Avoid edges/corners. Center is better.
            'n': [
                [0, -5,  0,  0,  0,  0,  0, -5,  0],
                [0,  5, 15, 15, 15, 15, 15,  5,  0],
                [5,  5, 15, 20, 20, 20, 15,  5,  5],
                [5, 10, 20, 30, 25, 30, 20, 10,  5],
                [5, 15, 25, 35, 35, 35, 25, 15,  5],
                [5, 15, 25, 35, 35, 35, 25, 15,  5],
                [5, 10, 20, 30, 25, 30, 20, 10,  5],
                [5,  5, 15, 20, 20, 20, 15,  5,  5],
                [0,  5, 15, 15, 15, 15, 15,  5,  0],
                [0, -5,  0,  0,  0,  0,  0, -5,  0]
            ],
            // Rook: Control open files.
            'r': [
                [0,  0,  0,  0,  0,  0,  0,  0,  0],
                [10, 20, 15, 20, 15, 20, 15, 20, 10],
                [10, 20, 15, 20, 15, 20, 15, 20, 10],
                [10, 20, 15, 20, 15, 20, 15, 20, 10],
                [10, 20, 15, 20, 15, 20, 15, 20, 10],
                [10, 20, 15, 20, 15, 20, 15, 20, 10],
                [10, 20, 15, 20, 15, 20, 15, 20, 10],
                [10, 20, 15, 20, 15, 20, 15, 20, 10],
                [10, 20, 15, 20, 15, 20, 15, 20, 10],
                [5, 15, 10, 15, 10, 15, 10, 15,  5]
            ],
            // Cannon: Central control is good.
            'c': [
                [0,  0,  0,  0,  0,  0,  0,  0,  0],
                [0, 10,  0, 10,  0, 10,  0, 10,  0],
                [0, 10, 20, 30, 50, 30, 20, 10,  0], // The "Hollow Central Cannon" spot
                [0, 10, 20, 20, 20, 20, 20, 10,  0],
                [0, 10, 20, 20, 20, 20, 20, 10,  0],
                [0, 10, 20, 20, 20, 20, 20, 10,  0],
                [0, 10, 20, 20, 20, 20, 20, 10,  0],
                [0, 10, 20, 30, 30, 30, 20, 10,  0],
                [0, 10,  0, 10,  0, 10,  0, 10,  0],
                [0,  0,  0,  0,  0,  0,  0,  0,  0]
            ],
            // King/Guard/Elephant: Defensive.
            'k': [[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]], 
            'a': [[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]],
            'b': [[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]]
        };

        const MATERIAL_VALUES = {
            'k': 10000, 'a': 20, 'b': 20, 'n': 400, 'r': 900, 'c': 450, 'p': 100 // Base values
        };

        function makeAiMove() {
            // Use iterative deepening-ish logic? No, just straight alpha-beta with new Eval
            // Add randomness to equal moves
            const moves = getAllMoves(board, AI_COLOR);
            if (moves.length === 0) { gameOver = true; showModal("Red Wins!"); return; }

            // Initial Sort for move ordering (Captures first)
            moves.sort((a, b) => {
                const valA = getPieceValue(board[a.to.r][a.to.c]);
                const valB = getPieceValue(board[b.to.r][b.to.c]);
                return valB - valA;
            });

            let bestMove = null;
            let bestValue = -Infinity;
            let alpha = -Infinity;
            let beta = Infinity;

            // Root search
            for (let move of moves) {
                const savedPiece = board[move.to.r][move.to.c];
                const movingPiece = board[move.from.r][move.from.c];
                
                board[move.to.r][move.to.c] = movingPiece;
                board[move.from.r][move.from.c] = '.';

                // Suicide Check (Flying General)
                if (generalsFaceEachOther(board)) {
                    board[move.from.r][move.from.c] = movingPiece;
                    board[move.to.r][move.to.c] = savedPiece;
                    continue;
                }

                // Instant win check
                if (savedPiece === 'K') {
                    board[move.from.r][move.from.c] = movingPiece;
                    board[move.to.r][move.to.c] = savedPiece;
                    executeMove(move.from, move.to);
                    isAiThinking = false;
                    return;
                }

                const value = minimax(aiDepth - 1, alpha, beta, false);
                
                board[move.from.r][move.from.c] = movingPiece;
                board[move.to.r][move.to.c] = savedPiece;

                if (value > bestValue) {
                    bestValue = value;
                    bestMove = move;
                }
                alpha = Math.max(alpha, value);
            }

            if (bestMove) {
                executeMove(bestMove.from, bestMove.to);
            } else {
                gameOver = true; showModal("Red Wins!");
            }
            isAiThinking = false;
        }

        function minimax(depth, alpha, beta, isMaximizing) {
            if (depth === 0) {
                // Quiescence Search at leaf nodes
                return quiescence(3, alpha, beta, isMaximizing); 
            }

            const color = isMaximizing ? AI_COLOR : PLAYER_COLOR;
            const moves = getAllMoves(board, color);

            if (moves.length === 0) return isMaximizing ? -Infinity : Infinity;

            // Move Ordering: Captures first
            moves.sort((a, b) => {
                const valA = getPieceValue(board[a.to.r][a.to.c]);
                const valB = getPieceValue(board[b.to.r][b.to.c]);
                return valB - valA;
            });

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let move of moves) {
                    const savedPiece = board[move.to.r][move.to.c];
                    const movingPiece = board[move.from.r][move.from.c];
                    
                    if (savedPiece === 'K') return 20000; 

                    board[move.to.r][move.to.c] = movingPiece;
                    board[move.from.r][move.from.c] = '.';
                    
                    if (generalsFaceEachOther(board)) {
                        board[move.from.r][move.from.c] = movingPiece;
                        board[move.to.r][move.to.c] = savedPiece;
                        continue; 
                    }

                    const eval = minimax(depth - 1, alpha, beta, false);
                    
                    board[move.from.r][move.from.c] = movingPiece;
                    board[move.to.r][move.to.c] = savedPiece;

                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let move of moves) {
                    const savedPiece = board[move.to.r][move.to.c];
                    const movingPiece = board[move.from.r][move.from.c];

                    if (savedPiece === 'k') return -20000;

                    board[move.to.r][move.to.c] = movingPiece;
                    board[move.from.r][move.from.c] = '.';
                    
                    if (generalsFaceEachOther(board)) {
                        board[move.from.r][move.from.c] = movingPiece;
                        board[move.to.r][move.to.c] = savedPiece;
                        continue;
                    }

                    const eval = minimax(depth - 1, alpha, beta, true);
                    
                    board[move.from.r][move.from.c] = movingPiece;
                    board[move.to.r][move.to.c] = savedPiece;

                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        // Quiescence Search: Only search captures to avoid horizon effect
        function quiescence(limit, alpha, beta, isMaximizing) {
            const standPat = evaluateBoard(board);
            if (limit === 0) return standPat;

            if (isMaximizing) {
                if (standPat >= beta) return beta;
                if (standPat > alpha) alpha = standPat;
            } else {
                if (standPat <= alpha) return alpha;
                if (standPat < beta) beta = standPat;
            }

            const color = isMaximizing ? AI_COLOR : PLAYER_COLOR;
            // Only get CAPTURE moves
            const moves = getAllMoves(board, color).filter(m => board[m.to.r][m.to.c] !== '.');
            
            // Sort by victim value (MVV/LVA lite)
            moves.sort((a, b) => {
                return getPieceValue(board[b.to.r][b.to.c]) - getPieceValue(board[a.to.r][a.to.c]);
            });

            for (let move of moves) {
                const savedPiece = board[move.to.r][move.to.c];
                const movingPiece = board[move.from.r][move.from.c];

                board[move.to.r][move.to.c] = movingPiece;
                board[move.from.r][move.from.c] = '.';

                 if (generalsFaceEachOther(board)) {
                    board[move.from.r][move.from.c] = movingPiece;
                    board[move.to.r][move.to.c] = savedPiece;
                    continue; 
                }

                // Recurse with limit - 1
                const score = quiescence(limit - 1, alpha, beta, !isMaximizing);

                board[move.from.r][move.from.c] = movingPiece;
                board[move.to.r][move.to.c] = savedPiece;

                if (isMaximizing) {
                    if (score >= beta) return beta;
                    if (score > alpha) alpha = score;
                } else {
                    if (score <= alpha) return alpha;
                    if (score < beta) beta = score;
                }
            }
            return isMaximizing ? alpha : beta;
        }

        function evaluateBoard(b) {
            let score = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const char = b[r][c];
                    if (char === '.') continue;
                    
                    const type = char.toLowerCase();
                    const val = MATERIAL_VALUES[type];
                    
                    // Position Bonus
                    let pstVal = 0;
                    if (PST[type]) {
                        if (char === char.toLowerCase()) {
                            // Black (AI) - Use table as is
                            pstVal = PST[type][r][c];
                        } else {
                            // Red (Player) - Mirror row index
                            pstVal = PST[type][9-r][c];
                        }
                    }

                    if (char === char.toLowerCase()) {
                        score += val + pstVal;
                    } else {
                        score -= (val + pstVal);
                    }
                }
            }
            // Add mobility bonus (approximated by just randomness to break ties for now, 
            // real mobility is too expensive for JS recursion in this structure)
            // score += Math.random() * 5; 
            return score;
        }

        function getPieceValue(char) {
            if (!char || char === '.') return 0;
            return MATERIAL_VALUES[char.toLowerCase()] || 0;
        }

        function getAllMoves(currentBoard, color) {
            let moves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const char = currentBoard[r][c];
                    if (char === '.') continue;
                    const pColor = (char === char.toUpperCase()) ? RED : BLACK;
                    if (pColor === color) {
                        const type = char.toLowerCase();
                        const valid = getValidMoves(r, c, type, color);
                        valid.forEach(v => moves.push({from: {r, c}, to: v}));
                    }
                }
            }
            return moves;
        }

        // --- Validation (Unchanged logic mostly) ---
        function getValidMoves(r, c, type, color) {
            let moves = [];
            const check = (nr, nc) => {
                if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) return false;
                const targetChar = board[nr][nc]; 
                if (targetChar !== '.') {
                    const targetColor = (targetChar === targetChar.toUpperCase()) ? RED : BLACK;
                    if (targetColor === color) return false;
                }
                return true;
            };

            if (type === 'k') {
                const deltas = [[0,1], [0,-1], [1,0], [-1,0]];
                deltas.forEach(([dr, dc]) => {
                    const nr = r + dr, nc = c + dc;
                    if (inPalace(nr, nc, color) && check(nr, nc)) moves.push({r: nr, c: nc});
                });
            } 
            else if (type === 'a') {
                const deltas = [[1,1], [1,-1], [-1,1], [-1,-1]];
                deltas.forEach(([dr, dc]) => {
                    const nr = r + dr, nc = c + dc;
                    if (inPalace(nr, nc, color) && check(nr, nc)) moves.push({r: nr, c: nc});
                });
            }
            else if (type === 'b') {
                const deltas = [[2,2], [2,-2], [-2,2], [-2,-2]];
                deltas.forEach(([dr, dc]) => {
                    const nr = r + dr, nc = c + dc;
                    if (color === RED && nr < 5) return;
                    if (color === BLACK && nr > 4) return;
                    const mr = r + dr/2, mc = c + dc/2;
                    if (check(nr, nc) && board[mr][mc] === '.') moves.push({r: nr, c: nc});
                });
            }
            else if (type === 'n') {
                const jumps = [
                    {dr: -2, dc: -1, block: {r: -1, c: 0}}, {dr: -2, dc: 1,  block: {r: -1, c: 0}},
                    {dr: 2,  dc: -1, block: {r: 1, c: 0}},  {dr: 2,  dc: 1,  block: {r: 1, c: 0}},
                    {dr: -1, dc: -2, block: {r: 0, c: -1}}, {dr: 1,  dc: -2, block: {r: 0, c: -1}},
                    {dr: -1, dc: 2,  block: {r: 0, c: 1}},  {dr: 1,  dc: 2,  block: {r: 0, c: 1}}
                ];
                jumps.forEach(j => {
                    const nr = r + j.dr, nc = c + j.dc;
                    const br = r + j.block.r, bc = c + j.block.c;
                    if (br >=0 && br < ROWS && bc >=0 && bc < COLS && board[br][bc] === '.') {
                         if (check(nr, nc)) moves.push({r: nr, c: nc});
                    }
                });
            }
            else if (type === 'r') {
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                dirs.forEach(([dr, dc]) => {
                    let nr = r + dr, nc = c + dc;
                    while(nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                        const pChar = board[nr][nc];
                        if (pChar === '.') {
                            moves.push({r: nr, c: nc});
                        } else {
                            const pColor = (pChar === pChar.toUpperCase()) ? RED : BLACK;
                            if (pColor !== color) moves.push({r: nr, c: nc});
                            break;
                        }
                        nr += dr; nc += dc;
                    }
                });
            }
            else if (type === 'c') {
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                dirs.forEach(([dr, dc]) => {
                    let nr = r + dr, nc = c + dc;
                    let screenFound = false;
                    while(nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                        const pChar = board[nr][nc];
                        if (!screenFound) {
                            if (pChar === '.') {
                                moves.push({r: nr, c: nc});
                            } else {
                                screenFound = true;
                            }
                        } else {
                            if (pChar !== '.') {
                                const pColor = (pChar === pChar.toUpperCase()) ? RED : BLACK;
                                if (pColor !== color) moves.push({r: nr, c: nc});
                                break;
                            }
                        }
                        nr += dr; nc += dc;
                    }
                });
            }
            else if (type === 'p') {
                const forward = (color === RED) ? -1 : 1;
                const crossedRiver = (color === RED) ? r <= 4 : r >= 5;
                if (check(r + forward, c)) moves.push({r: r + forward, c});
                if (crossedRiver) {
                    if (check(r, c - 1)) moves.push({r, c: c - 1});
                    if (check(r, c + 1)) moves.push({r, c: c + 1});
                }
            }
            return moves;
        }

        function inPalace(r, c, color) {
            if (c < 3 || c > 5) return false;
            if (color === RED) return r >= 7 && r <= 9;
            if (color === BLACK) return r >= 0 && r <= 2;
            return false;
        }

        window.onload = init;
    </script>
</body>
</html>