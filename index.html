<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xiangqi 2077 - Cyberpunk Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #050505;
            background-image: 
                linear-gradient(rgba(0, 20, 30, 0.8) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 20, 30, 0.8) 1px, transparent 1px);
            background-size: 40px 40px;
            color: #e0e0e0;
            touch-action: manipulation;
        }

        /* Neon Text Utilities */
        .text-neon-red { color: #ff0055; text-shadow: 0 0 5px #ff0055, 0 0 10px #ff0055; }
        .text-neon-blue { color: #00f3ff; text-shadow: 0 0 5px #00f3ff, 0 0 10px #00f3ff; }
        .text-neon-green { color: #00ff99; text-shadow: 0 0 5px #00ff99, 0 0 10px #00ff99; }

        #game-container {
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2), inset 0 0 20px rgba(0, 0, 0, 0.8);
            background: #0a0a12;
            border: 1px solid #00f3ff;
        }

        canvas {
            cursor: pointer;
            background-color: #08080c;
            border-radius: 2px;
        }

        /* UI Elements */
        .cyber-panel {
            background: rgba(10, 10, 18, 0.9);
            border: 1px solid #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }
        
        .cyber-btn {
            background: transparent;
            border: 1px solid currentColor;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        .cyber-btn:hover {
            box-shadow: 0 0 10px currentColor;
            background: rgba(255,255,255,0.1);
        }
        
        .cyber-select {
            background: #000;
            color: #00f3ff;
            border: 1px solid #00f3ff;
        }
        
        .skill-btn {
            background: rgba(0, 255, 153, 0.1);
            border: 1px solid #00ff99;
            color: #00ff99;
            text-shadow: 0 0 5px #00ff99;
            transition: all 0.3s ease;
        }
        .skill-btn:hover {
            background: rgba(0, 255, 153, 0.3);
            box-shadow: 0 0 15px #00ff99;
        }

        /* Loading spinner for AI thinking */
        .loader {
            border: 2px solid rgba(255, 0, 85, 0.1);
            border-radius: 50%;
            border-top: 2px solid #ff0055;
            width: 20px;
            height: 20px;
            animation: spin 0.8s linear infinite;
            box-shadow: 0 0 10px #ff0055;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="text-center mb-6">
        <h1 class="text-5xl font-bold text-neon-blue mb-2 tracking-widest">XIANGQI <span class="text-sm align-top opacity-70">2077</span></h1>
        <p class="text-gray-400 text-xs tracking-widest uppercase">Neural Network Uplink: <span class="text-neon-green">Active</span></p>
    </div>

    <div id="game-container" class="p-1 rounded relative">
        <canvas id="board" width="450" height="500"></canvas>
        
        <!-- Game Over Overlay -->
        <div id="game-over" class="hidden absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center z-10 backdrop-blur-sm">
            <div class="cyber-panel p-8 rounded border border-neon-red text-center">
                <h2 id="winner-text" class="text-3xl font-bold mb-6 text-neon-red tracking-widest">RED WINS</h2>
                <div class="flex gap-4 justify-center">
                    <button onclick="undoLastMove()" class="cyber-btn text-neon-blue py-2 px-6 rounded font-bold">
                        Revert
                    </button>
                    <button onclick="resetGame()" class="cyber-btn text-neon-red py-2 px-6 rounded font-bold">
                        Reboot
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="mt-8 flex flex-col items-center gap-4 w-full max-w-md cyber-panel p-4 rounded border-t border-gray-800">
        <div class="flex justify-between items-center w-full">
            <div class="flex flex-col gap-2">
                <div class="flex items-center gap-3">
                    <div class="w-3 h-3 rounded-full shadow-[0_0_10px_currentColor]" id="turn-dot"></div>
                    <span id="turn-indicator" class="font-bold tracking-wider text-lg">INITIALIZING...</span>
                    <div id="ai-loader" class="loader hidden"></div>
                </div>
                <div class="flex items-center gap-2 text-xs text-gray-500 uppercase tracking-wider">
                    <label>Protocol:</label>
                    <select id="game-mode" onchange="resetGame()" class="cyber-select px-2 py-1 rounded text-xs outline-none">
                        <option value="pvp">Human vs Human</option>
                        <option value="ai">Human vs Local CPU</option>
                    </select>
                </div>
            </div>
            <div class="flex gap-3 items-center">
                <!-- New Skill Button -->
                <button onclick="activateSkill()" class="skill-btn py-1 px-3 rounded font-bold text-xs uppercase tracking-wider mr-2">
                    全军出击
                </button>
                
                <button onclick="undoLastMove()" class="text-xs text-gray-400 hover:text-neon-blue transition uppercase tracking-widest">Undo</button>
                <button onclick="resetGame()" class="text-xs text-gray-400 hover:text-neon-red transition uppercase tracking-widest">Reset</button>
            </div>
        </div>
        
        <div id="message-box" class="text-neon-red font-mono h-5 text-xs text-center w-full"></div>
    </div>

    <script>
        // --- API Configuration ---
        const apiKey = ""; // Not used in local mode

        // --- Constants ---
        const COLS = 9;
        const ROWS = 10;
        const CELL_SIZE = 50;
        const MARGIN = 25; 
        const PIECE_RADIUS = 18; 
        
        // Cyberpunk Palette
        const COLOR_BG = '#08080c';
        const COLOR_GRID = '#1a2f38'; 
        const COLOR_GRID_GLOW = '#00f3ff'; 
        
        const COLOR_RED = '#ff0055'; 
        const COLOR_RED_DIM = 'rgba(255, 0, 85, 0.2)';
        
        const COLOR_BLACK = '#00ff99'; 
        const COLOR_BLACK_DIM = 'rgba(0, 255, 153, 0.2)';
        
        const COLOR_SELECT = 'rgba(255, 255, 255, 0.2)';
        const COLOR_LAST_MOVE = 'rgba(0, 243, 255, 0.15)';
        const COLOR_VALID_MOVE = 'rgba(0, 243, 255, 0.4)';

        // Piece Definitions
        const PIECES = {
            'k': { char: ['帥', '將'], name: 'General', val: 10000, fenChar: 'k' },
            'a': { char: ['仕', '士'], name: 'Advisor', val: 20, fenChar: 'a' },
            'e': { char: ['相', '象'], name: 'Elephant', val: 20, fenChar: 'b' }, 
            'h': { char: ['傌', '馬'], name: 'Horse', val: 40, fenChar: 'n' },
            'r': { char: ['俥', '車'], name: 'Chariot', val: 90, fenChar: 'r' }, 
            'c': { char: ['炮', '砲'], name: 'Cannon', val: 45, fenChar: 'c' },
            'p': { char: ['兵', '卒'], name: 'Soldier', val: 10, fenChar: 'p' }
        };

        // --- State ---
        let board = [];
        let turn = 'red'; 
        let selected = null; 
        let lastMove = null; 
        let gameOver = false;
        let isAiThinking = false;
        let moveHistory = [];

        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');

        // --- Initialization ---
        function initBoard() {
            board = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
            
            const setupRow = (row, color, typeStr) => {
                const types = typeStr.split('');
                types.forEach((type, col) => {
                    board[row][col] = { type, color };
                });
            };

            // Red (Bottom)
            setupRow(9, 'red', 'rheakaehr');
            board[7][1] = { type: 'c', color: 'red' };
            board[7][7] = { type: 'c', color: 'red' };
            [0, 2, 4, 6, 8].forEach(c => board[6][c] = { type: 'p', color: 'red' });

            // Black (Top)
            setupRow(0, 'black', 'rheakaehr');
            board[2][1] = { type: 'c', color: 'black' };
            board[2][7] = { type: 'c', color: 'black' };
            [0, 2, 4, 6, 8].forEach(c => board[3][c] = { type: 'p', color: 'black' });
        }

        function resetGame() {
            initBoard();
            turn = 'red';
            selected = null;
            lastMove = null;
            gameOver = false;
            isAiThinking = false;
            moveHistory = [];
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('message-box').innerText = "";
            updateUI();
            draw();
        }
        
        // --- Skill Logic ---
        function activateSkill() {
            if (gameOver || isAiThinking) return;
            
            // Check if it's human turn in AI mode
            const mode = document.getElementById('game-mode').value;
            if (mode === 'ai' && turn === 'black') return; 

            const movesToExecute = [];
            // Red moves Up (-1), Black moves Down (+1)
            const dr = turn === 'red' ? -1 : 1;

            // 1. Identify all valid soldier moves
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const p = board[r][c];
                    // Find friendly soldiers
                    if (p && p.color === turn && p.type === 'p') {
                        const nr = r + dr;
                        const nc = c; // Skill moves strictly forward
                        
                        if (isValidPos(nr, nc)) {
                            const target = board[nr][nc];
                            // Check if blocked by friendly
                            if (!target || target.color !== turn) {
                                movesToExecute.push({
                                    from: {r, c},
                                    to: {r: nr, c: nc},
                                    captured: target // could be null or enemy
                                });
                            }
                        }
                    }
                }
            }

            if (movesToExecute.length === 0) {
                document.getElementById('message-box').innerText = "UNABLE TO ADVANCE";
                return;
            }

            // 2. Execute all moves
            // Clear origins first
            movesToExecute.forEach(m => {
                board[m.from.r][m.from.c] = null;
            });
            
            let generalCaptured = false;
            // Place at destinations
            movesToExecute.forEach(m => {
                const piece = { type: 'p', color: turn };
                board[m.to.r][m.to.c] = piece;
                if (m.captured && m.captured.type === 'k') generalCaptured = true;
            });

            // 3. Update History (Batch Type)
            moveHistory.push({
                type: 'batch',
                moves: movesToExecute,
                turn: turn
            });

            // 4. Post-Move cleanup
            lastMove = null; // Clear highlights as multiple moved
            selected = null;
            document.getElementById('message-box').innerText = `ALL ARMY ATTACK: ${movesToExecute.length} UNITS ADVANCED`;

            if (generalCaptured) {
                endGame(turn === 'red' ? "RED WINS" : "BLACK WINS");
                return;
            }

            turn = turn === 'red' ? 'black' : 'red';
            draw();
            updateUI();

            // Trigger AI if needed
            if (mode === 'ai' && turn === 'black' && !gameOver) {
                makeAIMove();
            }
        }

        function undoLastMove() {
            if (isAiThinking || moveHistory.length === 0) return;
            const mode = document.getElementById('game-mode').value;
            
            const revertStep = () => {
                const last = moveHistory.pop();
                if (!last) return null;

                // Handle Batch Undo (Skill) vs Single Undo
                if (last.type === 'batch') {
                    last.moves.forEach(m => {
                        board[m.to.r][m.to.c] = m.captured; // Put back what was there (empty or enemy)
                        board[m.from.r][m.from.c] = { type: 'p', color: last.turn }; // Put soldier back
                    });
                } else {
                    board[last.from.r][last.from.c] = board[last.to.r][last.to.c];
                    board[last.to.r][last.to.c] = last.captured;
                }
                
                return last;
            };

            if (mode === 'ai') {
                if (moveHistory.length >= 2) {
                    revertStep(); revertStep(); turn = 'red';
                } else if (moveHistory.length === 1) {
                    revertStep(); turn = 'red';
                }
            } else {
                const last = revertStep();
                if (last) turn = last.turn;
            }

            gameOver = false;
            document.getElementById('game-over').classList.add('hidden');
            selected = null;
            
            // Restore last move highlight if it was a standard move
            if (moveHistory.length > 0) {
                const prev = moveHistory[moveHistory.length - 1];
                if (prev.type !== 'batch') {
                    lastMove = { from: prev.from, to: prev.to };
                } else {
                    lastMove = null;
                }
            } else {
                lastMove = null;
            }
            
            document.getElementById('message-box').innerText = "";
            updateUI();
            draw();
        }

        // --- Drawing ---
        function getX(c) { return MARGIN + c * CELL_SIZE; }
        function getY(r) { return MARGIN + r * CELL_SIZE; }

        function drawNeonLine(x1, y1, x2, y2, color = COLOR_GRID, width = 1) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
        }

        function drawBoardLines() {
            ctx.fillStyle = COLOR_BG;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.shadowBlur = 5;
            ctx.shadowColor = COLOR_GRID_GLOW;

            for (let r = 0; r < ROWS; r++) {
                drawNeonLine(getX(0), getY(r), getX(COLS - 1), getY(r));
            }
            for (let c = 0; c < COLS; c++) {
                drawNeonLine(getX(c), getY(0), getX(c), getY(4));
                drawNeonLine(getX(c), getY(5), getX(c), getY(9));
            }
            drawNeonLine(getX(0), getY(4), getX(0), getY(5));
            drawNeonLine(getX(8), getY(4), getX(8), getY(5));

            // Palaces
            drawNeonLine(getX(3), getY(0), getX(5), getY(2));
            drawNeonLine(getX(5), getY(0), getX(3), getY(2));
            drawNeonLine(getX(3), getY(9), getX(5), getY(7));
            drawNeonLine(getX(5), getY(9), getX(3), getY(7));

            ctx.shadowBlur = 0;

            ctx.fillStyle = 'rgba(0, 243, 255, 0.3)';
            ctx.font = "bold 16px 'Orbitron'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            const riverY = getY(4) + CELL_SIZE / 2;
            ctx.fillText("NULL SECTOR", getX(2), riverY);
            ctx.fillText("DATA STREAM", getX(6), riverY);
        }

        function drawPiece(r, c, piece) {
            const x = getX(c);
            const y = getY(r);
            const isRed = piece.color === 'red';
            const baseColor = isRed ? COLOR_RED : COLOR_BLACK;
            const dimColor = isRed ? COLOR_RED_DIM : COLOR_BLACK_DIM;

            ctx.shadowBlur = 15;
            ctx.shadowColor = baseColor;
            ctx.beginPath();
            ctx.arc(x, y, PIECE_RADIUS, 0, Math.PI * 2);
            ctx.strokeStyle = baseColor;
            ctx.lineWidth = 2;
            ctx.fillStyle = '#000';
            ctx.fill();
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.fillStyle = dimColor;
            ctx.fill();

            ctx.shadowBlur = 5;
            ctx.shadowColor = baseColor;
            ctx.fillStyle = baseColor;
            ctx.font = "bold 20px 'Orbitron', 'Noto Serif SC'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            const charIndex = isRed ? 0 : 1;
            const char = PIECES[piece.type].char[charIndex];
            ctx.fillText(char, x, y + 2);
            ctx.shadowBlur = 0;
        }

        function drawHighlights() {
            if (lastMove) {
                ctx.fillStyle = COLOR_LAST_MOVE;
                const { from, to } = lastMove;
                ctx.shadowBlur = 10;
                ctx.shadowColor = COLOR_GRID_GLOW;
                ctx.fillRect(getX(from.c) - CELL_SIZE/2 + 2, getY(from.r) - CELL_SIZE/2 + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                ctx.fillRect(getX(to.c) - CELL_SIZE/2 + 2, getY(to.r) - CELL_SIZE/2 + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                ctx.shadowBlur = 0;
            }
            if (selected) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.arc(getX(selected.c), getY(selected.r), PIECE_RADIUS + 6, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                const moves = getValidMoves(selected.r, selected.c);
                ctx.fillStyle = COLOR_VALID_MOVE;
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#00f3ff';
                moves.forEach(m => {
                    ctx.beginPath();
                    ctx.arc(getX(m.c), getY(m.r), 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.shadowBlur = 0;
            }
        }

        function draw() {
            drawBoardLines();
            drawHighlights();
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        drawPiece(r, c, board[r][c]);
                    }
                }
            }
        }

        // --- Logic ---
        function isValidPos(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }

        function getPseudoLegalMoves(r, c, piece) {
            const moves = [];
            const isRed = piece.color === 'red';
            const addIfValid = (nr, nc) => {
                if (!isValidPos(nr, nc)) return;
                const target = board[nr][nc];
                if (!target || target.color !== piece.color) moves.push({ r: nr, c: nc });
            };

            if (piece.type === 'k') {
                const dr = [-1, 1, 0, 0], dc = [0, 0, -1, 1];
                const rMin = isRed ? 7 : 0, rMax = isRed ? 9 : 2;
                for (let i = 0; i < 4; i++) {
                    const nr = r + dr[i], nc = c + dc[i];
                    if (nr >= rMin && nr <= rMax && nc >= 3 && nc <= 5) addIfValid(nr, nc);
                }
            } else if (piece.type === 'a') {
                const dr = [-1, -1, 1, 1], dc = [-1, 1, -1, 1];
                const rMin = isRed ? 7 : 0, rMax = isRed ? 9 : 2;
                for (let i = 0; i < 4; i++) {
                    const nr = r + dr[i], nc = c + dc[i];
                    if (nr >= rMin && nr <= rMax && nc >= 3 && nc <= 5) addIfValid(nr, nc);
                }
            } else if (piece.type === 'e') {
                const dr = [-2, -2, 2, 2], dc = [-2, 2, -2, 2];
                const er = [-1, -1, 1, 1], ec = [-1, 1, -1, 1];
                for (let i = 0; i < 4; i++) {
                    const nr = r + dr[i], nc = c + dc[i];
                    if (isRed && nr < 5) continue;
                    if (!isRed && nr > 4) continue;
                    if (isValidPos(r+er[i], c+ec[i]) && !board[r+er[i]][c+ec[i]]) addIfValid(nr, nc);
                }
            } else if (piece.type === 'h') {
                const jumps = [{r:-2,c:-1,lr:-1,lc:0}, {r:-2,c:1,lr:-1,lc:0}, {r:2,c:-1,lr:1,lc:0}, {r:2,c:1,lr:1,lc:0},
                               {r:-1,c:-2,lr:0,lc:-1}, {r:1,c:-2,lr:0,lc:-1}, {r:-1,c:2,lr:0,lc:1}, {r:1,c:2,lr:0,lc:1}];
                for (let j of jumps) {
                    const nr = r + j.r, nc = c + j.c, lr = r + j.lr, lc = c + j.lc;
                    if (isValidPos(nr, nc) && isValidPos(lr, lc) && !board[lr][lc]) addIfValid(nr, nc);
                }
            } else if (piece.type === 'r' || piece.type === 'c') {
                const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (let d of dirs) {
                    let dist = 1, jumped = false;
                    while (true) {
                        const nr = r + d[0] * dist, nc = c + d[1] * dist;
                        if (!isValidPos(nr, nc)) break;
                        const target = board[nr][nc];
                        if (piece.type === 'r') {
                            if (!target) moves.push({r:nr, c:nc});
                            else { if (target.color !== piece.color) moves.push({r:nr, c:nc}); break; }
                        } else {
                            if (!jumped) {
                                if (!target) moves.push({r:nr, c:nc}); else jumped = true;
                            } else {
                                if (target) { if (target.color !== piece.color) moves.push({r:nr, c:nc}); break; }
                            }
                        }
                        dist++;
                    }
                }
            } else if (piece.type === 'p') {
                const dr = isRed ? -1 : 1;
                addIfValid(r + dr, c);
                const crossedRiver = isRed ? (r <= 4) : (r >= 5);
                if (crossedRiver) { addIfValid(r, c - 1); addIfValid(r, c + 1); }
            }
            return moves;
        }

        function causesFlyingGeneral(move) {
            const tempBoard = board.map(row => [...row]);
            tempBoard[move.to.r][move.to.c] = tempBoard[move.from.r][move.from.c];
            tempBoard[move.from.r][move.from.c] = null;
            
            let redK, blackK;
            for(let r=0; r<ROWS; r++) {
                for(let c=3; c<=5; c++) { 
                    const p = tempBoard[r][c];
                    if(p && p.type === 'k') {
                        if(p.color === 'red') redK = {r, c}; else blackK = {r, c};
                    }
                }
            }
            if(redK && blackK && redK.c === blackK.c) {
                for(let r = Math.min(redK.r, blackK.r) + 1; r < Math.max(redK.r, blackK.r); r++) {
                    if(tempBoard[r][redK.c]) return false;
                }
                return true;
            }
            return false;
        }

        function getValidMoves(r, c) {
            const piece = board[r][c];
            if (!piece) return [];
            let moves = getPseudoLegalMoves(r, c, piece);
            return moves.filter(m => !causesFlyingGeneral({from: {r, c}, to: m}));
        }

        function getAllMoves(color) {
            let allMoves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const p = board[r][c];
                    if (p && p.color === color) {
                        const moves = getValidMoves(r, c);
                        moves.forEach(to => allMoves.push({ from: {r, c}, to }));
                    }
                }
            }
            return allMoves;
        }

        function executeMove(move) {
            const target = board[move.to.r][move.to.c];
            const winner = (target && target.type === 'k');
            
            board[move.to.r][move.to.c] = board[move.from.r][move.from.c];
            board[move.from.r][move.from.c] = null;
            
            return winner;
        }

        // --- Standard AI (Minimax) ---

        function evaluateBoard(activeColor) {
            let score = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const p = board[r][c];
                    if (p) {
                        let val = PIECES[p.type].val;
                        if (p.type === 'p') {
                            if (p.color === 'red' && r < 5) val += 10;
                            if (p.color === 'black' && r > 4) val += 10;
                            if (c >= 3 && c <= 5) val += 10;
                        }
                        score += (p.color === 'black' ? val : -val);
                    }
                }
            }
            return score;
        }

        function minimax(depth, isMaximizing, alpha, beta) {
            if (depth === 0) return evaluateBoard();

            const moves = getAllMoves(isMaximizing ? 'black' : 'red');
            if (moves.length === 0) return isMaximizing ? -100000 : 100000;

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let move of moves) {
                    const savedTarget = board[move.to.r][move.to.c];
                    const savedSource = board[move.from.r][move.from.c];
                    board[move.to.r][move.to.c] = savedSource;
                    board[move.from.r][move.from.c] = null;
                    
                    if (savedTarget && savedTarget.type === 'k') {
                        board[move.from.r][move.from.c] = savedSource; board[move.to.r][move.to.c] = savedTarget;
                        return 100000;
                    }

                    const eval = minimax(depth - 1, false, alpha, beta);
                    board[move.from.r][move.from.c] = savedSource;
                    board[move.to.r][move.to.c] = savedTarget;

                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let move of moves) {
                    const savedTarget = board[move.to.r][move.to.c];
                    const savedSource = board[move.from.r][move.from.c];
                    board[move.to.r][move.to.c] = savedSource;
                    board[move.from.r][move.from.c] = null;

                    if (savedTarget && savedTarget.type === 'k') {
                        board[move.from.r][move.from.c] = savedSource; board[move.to.r][move.to.c] = savedTarget;
                        return -100000;
                    }

                    const eval = minimax(depth - 1, true, alpha, beta);
                    board[move.from.r][move.from.c] = savedSource;
                    board[move.to.r][move.to.c] = savedTarget;

                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function getMinimaxMove() {
             const depth = 3;
             let bestMove = null;
             let bestValue = -Infinity;
             const moves = getAllMoves('black');
             
             for (let move of moves) {
                 const savedTarget = board[move.to.r][move.to.c];
                 const savedSource = board[move.from.r][move.from.c];
                 
                 board[move.to.r][move.to.c] = savedSource;
                 board[move.from.r][move.from.c] = null;
                 
                 if (savedTarget && savedTarget.type === 'k') {
                     bestMove = move;
                     board[move.from.r][move.from.c] = savedSource; board[move.to.r][move.to.c] = savedTarget;
                     break; 
                 }

                 const moveValue = minimax(depth - 1, false, -Infinity, Infinity);
                 
                 board[move.from.r][move.from.c] = savedSource;
                 board[move.to.r][move.to.c] = savedTarget;

                 if (moveValue > bestValue) {
                     bestValue = moveValue;
                     bestMove = move;
                 }
             }
             return bestMove;
        }

        // --- Gemini API Helper (Multimodal) ---

        function getBoardImage() {
            const dataURL = canvas.toDataURL('image/png');
            // Remove the data:image/png;base64, prefix
            return dataURL.split(',')[1]; 
        }

        async function callGeminiAPI(systemPrompt, userPrompt, imageBase64 = null) {
            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                
                // Construct payload with optional image
                const parts = [];
                parts.push({ text: userPrompt });
                
                if (imageBase64) {
                    parts.push({
                        inlineData: {
                            mimeType: "image/png",
                            data: imageBase64
                        }
                    });
                }

                const payload = {
                    contents: [{ role: "user", parts: parts }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: { responseMimeType: "application/json" }
                };

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) throw new Error("No text in response");
                
                return JSON.parse(text);
            } catch (error) {
                console.error("Gemini API Error:", error);
                return null;
            }
        }

        // --- Main AI Controller ---

        function makeAIMove() {
            isAiThinking = true;
            updateUI();

            // Use setTimeout to allow the UI to update ("CALCULATING...") before the heavy JS runs
            setTimeout(() => {
                const bestMove = getMinimaxMove();

                if (bestMove) {
                    const target = board[bestMove.to.r][bestMove.to.c];
                    moveHistory.push({ from: bestMove.from, to: bestMove.to, captured: target, turn: 'black' });

                    const winner = executeMove(bestMove);
                    lastMove = bestMove;
                    if (winner) endGame("BLACK WINS");
                    else {
                        turn = 'red';
                        isAiThinking = false;
                        updateUI();
                        draw();
                    }
                } else {
                    endGame("RED WINS");
                }
            }, 50);
        }

        function endGame(winnerName) {
            gameOver = true;
            isAiThinking = false;
            draw();
            document.getElementById('winner-text').innerText = winnerName;
            document.getElementById('game-over').classList.remove('hidden');
            updateUI();
        }

        // --- Input Handling ---

        function updateUI() {
            const ind = document.getElementById('turn-indicator');
            const dot = document.getElementById('turn-dot');
            const loader = document.getElementById('ai-loader');
            
            if (isAiThinking) {
                ind.innerText = "CALCULATING...";
                ind.className = "font-bold tracking-wider text-lg text-neon-green animate-pulse";
                dot.className = "w-3 h-3 rounded-full shadow-[0_0_10px_currentColor] bg-[#00ff99]";
                loader.classList.remove('hidden');
            } else {
                ind.innerText = turn === 'red' ? "PLAYER TURN" : "OPPONENT TURN";
                ind.className = `font-bold tracking-wider text-lg ${turn === 'red' ? 'text-neon-red' : 'text-neon-green'}`;
                dot.className = `w-3 h-3 rounded-full shadow-[0_0_10px_currentColor] transition-colors ${turn === 'red' ? 'bg-[#ff0055]' : 'bg-[#00ff99]'}`;
                loader.classList.add('hidden');
            }
        }

        function handleClick(e) {
            if (gameOver || isAiThinking) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            const c = Math.round((x - MARGIN) / CELL_SIZE);
            const r = Math.round((y - MARGIN) / CELL_SIZE);

            if (!isValidPos(r, c)) return;

            const mode = document.getElementById('game-mode').value;
            if (mode === 'ai' && turn === 'black') return;

            const clickedPiece = board[r][c];

            if (selected) {
                const validMoves = getValidMoves(selected.r, selected.c);
                const isMove = validMoves.some(m => m.r === r && m.c === c);

                if (isMove) {
                    const target = board[r][c];
                    moveHistory.push({ from: selected, to: {r, c}, captured: target, turn: turn });

                    const winner = executeMove({from: selected, to: {r, c}});
                    lastMove = { from: selected, to: {r, c} };
                    selected = null;
                    
                    if (winner) {
                        endGame(turn === 'red' ? "RED WINS" : "BLACK WINS");
                        return;
                    }

                    turn = turn === 'red' ? 'black' : 'red';
                    draw();
                    updateUI();

                    if (mode === 'ai' && turn === 'black' && !gameOver) {
                        makeAIMove();
                    }
                    return;
                }
            }

            if (clickedPiece && clickedPiece.color === turn) {
                selected = {r, c};
                draw();
            } else {
                selected = null;
                draw();
            }
        }

        canvas.addEventListener('click', handleClick);
        initBoard();
        draw();
    </script>
</body>
</html>
